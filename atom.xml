<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闲鱼在线</title>
  
  <subtitle>混得今朝混今夜，忘却浮生祭韶华</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dxy2000.com/"/>
  <updated>2020-03-10T07:11:22.575Z</updated>
  <id>http://dxy2000.com/</id>
  
  <author>
    <name>Mark</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>刷题第一天——简单的“A+B”问题</title>
    <link href="http://dxy2000.com/2020/02/28/%E5%88%B7%E9%A2%98%E7%AC%AC1%E5%A4%A9%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%E7%9A%84%E2%80%9CA+B%E2%80%9D%E9%97%AE%E9%A2%98/"/>
    <id>http://dxy2000.com/2020/02/28/%E5%88%B7%E9%A2%98%E7%AC%AC1%E5%A4%A9%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%E7%9A%84%E2%80%9CA+B%E2%80%9D%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-28T14:45:14.678Z</published>
    <updated>2020-03-10T07:11:22.575Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><p>今天是算法刷题的第一天，主要是想熟悉一下刷题的感觉，提高一下代码的能力，为以后保研、找工作等等打基础。</p><p>今天所选的题目是</p><p>1.<code>LeetCode</code>平台上的无重复的最长子串</p><p>2.<code>LinkCode</code>平台上的 <code>A+B</code>问题</p><p>3.<code>Trailing Zero</code>问题。</p><p>这些都是一些基础的问题，不涉及动态规划等较难的算法，今天刷题的目的旨在熟悉平台找找手感，以后在去专门找专题有针对性地刷题。</p><p>下面是我在今天做题时的一些心得以及代码（由于在下水平有限且经验不足，三题解法均参考官方答案或论坛大神</p></blockquote><h4 id="1-无重复字符的最长子串"><a href="#1-无重复字符的最长子串" class="headerlink" title="1. 无重复字符的最长子串"></a>1. 无重复字符的最长子串</h4><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><p>问题描述：</p><p><em>Given a string, find the length of the longest substring without repeating characters.</em></p><p>样例：</p><p><strong>Input</strong>:<br><code>abcabcbb</code> </p><p>​             <code>bbbbbb</code></p><p>​             <code>pwwkew</code></p><p><strong>Output</strong>:<br>3  // <code>abc</code></p><p>​1  // <code>b</code></p><p>​3  // <code>wke</code>, not <code>pwke</code> for the reason that <code>pwke</code> is a <em>subsequence</em> not a <strong>substring</strong> )</p><p>语言：<em>Java</em></p><p><strong>思路①：</strong></p><p>​    拿到这道题的时候，第一个想法就是<strong>暴力搜索</strong>所有的子字符串，然后判断每一个子字符串是否存在重复的字符，若没有则记录该子字符串的长度并与当前存在的长度的最大值进行比较。最终得出的最长长度就是题目所要的结果。</p><p>思路理清，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length()-<span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(allMatched(s,i,j))&#123;</span><br><span class="line">ans = Math.max(ans,j-i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allMatched</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">Set&lt;Character&gt;set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; end; i++)&#123;</span><br><span class="line">Character c = str.charAt(c);</span><br><span class="line"><span class="keyword">if</span>(set.containsKey(c))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">set.add(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>:</p><p>显然，该代码种存在一个三重循环，即方法<code>lengthOfLongestSubstring</code>的两个<code>for</code>循环和方法<code>allMatched</code>的一个<code>for</code>循环，三个循环嵌套。则该暴力方法的时间复杂度为$O(n^3)$。因为太慢，所以在提交的时候系统会判定超时。所以这种思路仅供参考。</p><p><strong>思路②：</strong></p><p>第二个思路也是今天复习到以前数据结构课上学到的一种方法——<strong>滑动窗口方法(Sliding Window)</strong></p><p>在暴力方法种，我们花费了很多时间去检验每一个子字符串是否存在重复字符，但实际上我们并不需要这么做，原因在于在字符串索引区间[$i$, $j-1$]上，我们已经确认了子字符串$s_{i{j-1}}$中没有重复的字符，只需要判断$s[j]$是否存在于子字符串$s_{i{j-1}}$中即可（$s_{i{j-1}}$中的除其自身之外的所有子字符串的长度必定小于$s_{i{j-1}}$，所以无需再次判断，这样可以节省很多时间）。</p><p>若$s[j]$存在于$s_{i{j-1}}$中，则将窗口的首端索引$i$自增一，直到$s[j]$不再存在于$s_{i{j-1}}$中或者$i=j$时为止；</p><p>若$s[j]$不存在于$s_{i{j-1}}$中，则将窗口的末端索引$j$自增一，直到$s[j]$出现在$s_{i{j-1}}$中或者达到字符串尾端为止。</p><p>（动画示意图以后再加~）</p><p>思路理清，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; s.length() &amp;&amp; j &lt; s.length())&#123;</span><br><span class="line"><span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                <span class="comment">// 若不存在，则加入到子字符串中，并将窗口往前滑</span></span><br><span class="line">set.add(s.charAt(j++));</span><br><span class="line">ans = Math.max(ans, j-i);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 若存在，则将窗口首端向前滑一格</span></span><br><span class="line">set.remove(s.charAt(i++));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><pre><code> 该算法的最坏时间复杂度为$O(2n)$，即遍历两遍该字符串（滑动窗口的尾端遍历一遍，首端遍历一遍）</code></pre><p>​    空间复杂度为$S(min(m,n))$。滑动窗口法需要 $O(k)$的空间，其中 <em>k</em> 表示 <code>Set</code> 的大小。而 <code>Set</code> 的大小取决于字符串 <em>n</em>的大小以及字符集 / 字母 <em>m</em> 的大小。</p><p><strong>思路③：</strong></p><p>第三个方法的核心还是滑动窗口方法，只不过我们不再需要将字符串遍历两遍。实际上，我们只需要遍历一遍该字符串，就能得到我们想要的答案。</p><p>换句话说，若有与$s[j]$重复的字符$s[j’]$，则我们不再需要将首端索引$i$自增一，而是之间将$i$变为$j’+1$即可（$\forall i’\in[i,j’)$，由于$[j’,j_0] \in [i’,j_1]$，因而$s_{i’{j_1}}$一定会包含$s_{j’{j_0}}$这个包含重复字符的子字符串，所以不需要将$i$自增一，直接跳到$j’+1$就行）</p><p>思路理清，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(s.charAt(j)))&#123;</span><br><span class="line">i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">&#125;</span><br><span class="line">ans = Math.max(ans, j-i+<span class="number">1</span>);</span><br><span class="line">map.put(s.charAt(j), j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解读：第<code>5</code>行的判断语句如果没有判定成功，即第$j$个字符不在<code>Map</code>中，我们则把它加入<code>Map</code>中，并更新它的下标；若判定成功，则将$i$的值更新为第$j$个字符上一次出现的位置，之后更新第$j$个字符的位置为当前位置，等到下一次再次遇到该字符时，第$i$个字符的值就为字符$j$现在所在的位置。（表达能力有限，说得有点绕）</p><p>综上，该问题总共采用了三种方法，其中，后两种的方法所采用的核心思想一致，均为滑动窗口算法。该算法在计算机网络方面上也有着较为重要的应用（TCP协议的可靠传输），因此，掌握该方法还需要深入了解并多加应用。</p><h3 id="2-A-B-Problem"><a href="#2-A-B-Problem" class="headerlink" title="2. A + B Problem"></a>2. A + B Problem</h3><p>题目来源：<a href="https://www.lintcode.com/problem/a-b-problem/description" target="_blank" rel="noopener">https://www.lintcode.com/problem/a-b-problem/description</a></p><p>问题描述：</p><p><em>Write a function that add two numbers A and B (a and b both 32-bit integers, and we you can use bit operation)</em></p><p><em>Challenge: Don’t use + or any arithmetic operators.</em></p><p>思路：</p><blockquote><p>该问题如果用简单的<code>&quot;a+b&quot;</code>，一行代码就能AC。但是题目里的挑战要求我们不使用➕，而是用位运算来解决问题。</p><p>关于位运算的解法思路，也是参考的Discuss中的大神们。具体的做法如下：</p><p>我们随意选取两个数$a = 3,b=5$</p><p>换成二进制的写法，就是$a = 0011, b = 0101$</p><p>我们可以用$a\bigoplus b$ 来表示<strong>无进位加法</strong></p><p>用$(a \bigwedge b) &lt;&lt; 1$来表示<strong>进位</strong></p><p>则在该例中，a^b = 0110,  (a&amp;b)&lt;&lt;1 = 0010</p><p>我们将得到的两个值分别赋给a和b，再次做同样的运算可得：</p><p>a^b = 0100, (a&amp;b)&lt;&lt;1 = 0100</p><p>之后递归地进行这种方法，直到$b=0$停止：</p><p>a^b = 0000, (a&amp;b)&lt;&lt;1 = 1000</p><p>a^b = 1000, (a&amp;b)&lt;&lt;1 = 0000 </p><p>至此，运算结束，我们的结果为1000，也就是8.</p></blockquote><p>语言：$java$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a: An integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b: An integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The sum of a and b </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">aplusb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> add(a,b);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> add(a^b, (a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说，非常牛逼。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;今天是算法刷题的第一天，主要是想熟悉一下刷题的感觉，提高一下代码的能力，为以后保研、找工作等等打基础。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Diary" scheme="http://dxy2000.com/categories/Diary/"/>
    
    
      <category term="Java" scheme="http://dxy2000.com/tags/Java/"/>
    
      <category term="Algorithm" scheme="http://dxy2000.com/tags/Algorithm/"/>
    
  </entry>
  
</feed>
